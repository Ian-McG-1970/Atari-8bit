 ICL 'hardware.s'
 
;	SCN		EQU	49152
	SCREEN_MODE	EQU	$0E
	SM			EQU	SCREEN_MODE
	BLANK_LINE	EQU $70
	SCREEN_ADR	EQU	$40
	DISP_LIST	EQU	$41
	DLI_INT_SET		EQU	$80
	DLI_INT_CLR		EQU	$FF-DLI_INT_SET
	VBI_POS		EQU $6F-1

	REGA 	EQU	128
	REGX	EQU	REGA +1
	REGY	EQU	REGX +1
	SCR 	EQU	REGY +1
	SCR_LO	EQU	SCR
	SCR_HI	EQU	SCR +1
	NEXT_SPRITE	EQU	SCR_HI +1

.MACRO	BORDER	COL
			LDA #:1
			STA COLBK
.ENDM 

	ORG $800
	
init	LDA PORTB ; disable basic
		ORA #$02
		STA PORTB
			 	
		LDA #$00 ; disable antic
	    STA SDMCTL
	    STA DMACTL

		LDA #$98 	; set colours
		STA	COLPF0 
		STA COLOR0
		LDA #$C2
		STA	COLPF1 
		STA COLOR1
		LDA #$08
		STA COLPF2 
		STA COLOR2
		LDA #$76
		STA COLPF3 
		STA COLOR3
		LDA #0
		STA COLBK 
		STA COLOR4; background / border

		lda #<DISPLAY_LIST	; load display list & fill with test data
        sta SDLSTL
        lda #>DISPLAY_LIST
        sta SDLSTL+1
		
        LDX #<DLI_SPR	; load display list interrupt address
        LDY #>DLI_SPR
		STX VDSLST
        STY VDSLST+1
   
		lda #3          ; turn on missiles & players
		sta GRACTL      ; no shadow for this one
;		LDA #%00111101 			; 0=na, 0=na, 1=dma access on, 1=player 5 on, 1=player dma on, 1=missile dma on, 01=narrow
        lda #$3d ; #$3e        ; single line, both players & missiles
        sta SDMCTL      ; shadow of DMACTL
        sta DMACTL      ; shadow of DMACTL

        lda #>SPRITE0_TAB ; high byte of player storage
        sta PMBASE  ; missiles = $7b00, player0 = $7c00

        lda #32+16+1 ; 16+1          ; players in front of playfields and 5th player and 3rd colour
        sta PRIOR      ; shadow of PRIOR
        sta GPRIOR      ; shadow of PRIOR

		lda #0 ;0 ; 0 ;1
		sta SIZEP0
		sta SIZEP1
		sta SIZEP2
		sta SIZEP3
;		LDA #0 ;%01010101
		STA SIZEM

		LDA #0 
		LDX #<PM_SHAPE_TAB
		LDY #>PM_SHAPE_TAB
		STX SCR+0
		STY SCR+1
		LDX #>2048
		LDY #<2048
		JSR	MEMSET

		LDA #0 
		LDX #<SCN
		LDY #>SCN
		STX SCR+0
		STY SCR+1
		LDX #>4096
		LDY #<4096
		JSR	MEMSET

        lda #NMIEN_VBI | NMIEN_DLI	; activate display list interrupt
        sta NMIEN

MLOOP	JMP MLOOP

	.ALIGN $100
SPRITE_CLR_0
					STA SPRITE0_TAB+0,Y
					STA SPRITE0_TAB+1,Y
					STA SPRITE0_TAB+2,Y
					STA SPRITE0_TAB+3,Y
					STA SPRITE0_TAB+4,Y
					STA SPRITE0_TAB+5,Y
					STA SPRITE0_TAB+6,Y
					STA SPRITE0_TAB+7,Y
				DEX
				BPL COS_LOOP
			RTS
SPRITE_CLR_1
					STA SPRITE1_TAB+0,Y
					STA SPRITE1_TAB+1,Y
					STA SPRITE1_TAB+2,Y
					STA SPRITE1_TAB+3,Y
					STA SPRITE1_TAB+4,Y
					STA SPRITE1_TAB+5,Y
					STA SPRITE1_TAB+6,Y
					STA SPRITE1_TAB+7,Y
				DEX
				BPL COS_LOOP
			RTS

CLEAR_OLD_SPRITES
			LDA	#0
			LDX SPR_CNT
COS_LOOP		LDY	SPR_CLR_POS,X
				STY	ADR+1
				LDY	SPR_VER,X
ADR				JMP SPRITE_CLR_0
				DEX
				BPL COS_LOOP
			RTS

SPRITE_CLR_2
					STA SPRITE2_TAB+0,Y
					STA SPRITE2_TAB+1,Y
					STA SPRITE2_TAB+2,Y
					STA SPRITE2_TAB+3,Y
					STA SPRITE2_TAB+4,Y
					STA SPRITE2_TAB+5,Y
					STA SPRITE2_TAB+6,Y
					STA SPRITE2_TAB+7,Y
				DEX
				BPL COS_LOOP
			RTS
SPRITE_CLR_3
					STA SPRITE3_TAB+0,Y
					STA SPRITE3_TAB+1,Y
					STA SPRITE3_TAB+2,Y
					STA SPRITE3_TAB+3,Y
					STA SPRITE3_TAB+4,Y
					STA SPRITE3_TAB+5,Y
					STA SPRITE3_TAB+6,Y
					STA SPRITE3_TAB+7,Y
				DEX
				BPL COS_LOOP
			RTS
SPRITE_CLR_4
					STA SPRITE4_TAB+0,Y
					STA SPRITE4_TAB+1,Y
					STA SPRITE4_TAB+2,Y
					STA SPRITE4_TAB+3,Y
					STA SPRITE4_TAB+4,Y
					STA SPRITE4_TAB+5,Y
					STA SPRITE4_TAB+6,Y
					STA SPRITE4_TAB+7,Y
				DEX
				BPL COS_LOOP
			RTS

	.ALIGN $100
SPRITE_SET_0
					STA SPRITE0_TAB+0,Y
					STA SPRITE0_TAB+1,Y
					STA SPRITE0_TAB+2,Y
					STA SPRITE0_TAB+3,Y
					STA SPRITE0_TAB+4,Y
					STA SPRITE0_TAB+5,Y
					STA SPRITE0_TAB+6,Y
					STA SPRITE0_TAB+7,Y
				DEX
				BPL SNS_LOOP
			RTS
SPRITE_SET_1
					STA SPRITE1_TAB+0,Y
					STA SPRITE1_TAB+1,Y
					STA SPRITE1_TAB+2,Y
					STA SPRITE1_TAB+3,Y
					STA SPRITE1_TAB+4,Y
					STA SPRITE1_TAB+5,Y
					STA SPRITE1_TAB+6,Y
					STA SPRITE1_TAB+7,Y
				DEX
				BPL SNS_LOOP
			RTS
SET_NEW_SPRITES
			LDA	#$FF
			LDX SPR_CNT
SNS_LOOP		LDY	SPR_CLR_POS,X
				STY	SNS_ADDR+1
				LDY	SPR_VER,X
SNS_ADDR		JMP SPRITE_SET_0
				DEX
				BPL SNS_LOOP
			RTS
SPRITE_SET_2
					STA SPRITE2_TAB+0,Y
					STA SPRITE2_TAB+1,Y
					STA SPRITE2_TAB+2,Y
					STA SPRITE2_TAB+3,Y
					STA SPRITE2_TAB+4,Y
					STA SPRITE2_TAB+5,Y
					STA SPRITE2_TAB+6,Y
					STA SPRITE2_TAB+7,Y
				DEX
				BPL SNS_LOOP
			RTS
SPRITE_SET_3
					STA SPRITE3_TAB+0,Y
					STA SPRITE3_TAB+1,Y
					STA SPRITE3_TAB+2,Y
					STA SPRITE3_TAB+3,Y
					STA SPRITE3_TAB+4,Y
					STA SPRITE3_TAB+5,Y
					STA SPRITE3_TAB+6,Y
					STA SPRITE3_TAB+7,Y
				DEX
				BPL SNS_LOOP
			RTS
SPRITE_SET_4
					STA SPRITE4_TAB+0,Y
					STA SPRITE4_TAB+1,Y
					STA SPRITE4_TAB+2,Y
					STA SPRITE4_TAB+3,Y
					STA SPRITE4_TAB+4,Y
					STA SPRITE4_TAB+5,Y
					STA SPRITE4_TAB+6,Y
					STA SPRITE4_TAB+7,Y
				DEX
				BPL SNS_LOOP
			RTS

	.ALIGN $100
SETUP_FIRST_5_SPRITES_AND_DLIS
			LDX	SPR_CNT
			LDA	SPR_FIRST_TAB,X
			STA SPR_FIRST_ADDR+1

SPR_FIRST_ADDR	JMP	SPRITE_FIRST_4

SPRITE_FIRST_4	LDA SPR_HOR+4 ; 1st / 2nd / 3rd / 4th / 5th = pos(4)
				STA HPOSM3
				CLC
				ADC #2
				STA HPOSM2
				ADC #2
				STA HPOSM1
				ADC #2
				STA HPOSM0
				LDA	SPR_COL+4
;				STA COLOR3
				STA COLPF3

SPRITE_FIRST_3	LDA SPR_HOR+3 ; 1st / 2nd / 3rd / 4th = pos(3)
				STA HPOSP3
				LDA	SPR_COL+3
;				STA COLPM3
				STA PCOLR3

SPRITE_FIRST_2	LDA SPR_HOR+2 ; 1st / 2nd / 3rd = pos(2)
				STA HPOSP2
				LDA	SPR_COL+2
;				STA COLPM2
				STA PCOLR2

SPRITE_FIRST_1	LDA SPR_HOR+1 ; 1st + 2nd = pos(1)
				STA HPOSP1
				LDA	SPR_COL+1
;				STA COLPM1
				STA PCOLR1

SPRITE_FIRST_0	LDA SPR_HOR+0 ; 1st = pos(0)
				STA HPOSP0
				LDA SPR_COL+0
;				STA COLPM0
				STA PCOLR0

			CPX	#4	; SPRITE COUNT
			BCC DLI_EXIT ; less than or equal to 4 then exit

SET_NEW_DLI	LDY #5
			STY NEXT_SPRITE

			SEC
; set spr_ver_dli_list+4 to 0, read through spr_ver_list from 5 to end, subtract 2 and store in spr_ver_dli_list, if spr_ver_dli_list-1 and spr_ver_dli_list are within 2 make them the same as spr_ver_dli_list-1 and spr_ver_dli_list are within 2 make spr_ver_dli_list the same as spr_ver_dli_list-1
VER_DLI_LOOP	LDA	SPR_VER,Y 	; get sprite ver pos - 2
				SEC
				SBC #3
				TAX				; and backup in x

				SEC
				SBC #2
				CMP	SPR_VER_DLI-1,Y	; of one above is less than 2 higher
;				BCC VER_DLI_CONT
;					LDX	SPR_VER_DLI-1,Y ; replace current with previous
VER_DLI_CONT	TXA
				STA	SPR_VER_DLI,Y	; store dli pos for line
				INY
				CPY SPR_CNT
				BCC VER_DLI_LOOP

			LDY NEXT_SPRITE
SPR_LOOP		LDX	SPR_VER_DLI,Y 	; get sprite ver pos - use spr_ver_dli_list (see above)
				LDA	DLI_TAB,X	; get dli pos for line
				TAX
				LDA	DISPLAY_LIST,X	; set dli at that screen line
				ORA #DLI_INT_SET
				STA DISPLAY_LIST,X
				INY
				CPY SPR_CNT
				BCC SPR_LOOP
DLI_EXIT	RTS

.LOCAL	CLEAR_OLD_DLI_SET_LAST_DLI
			LDY	SPR_CNT
LOOP			LDX	SPR_VER_DLI,Y 	; get sprite ver pos
				LDA	DLI_TAB,X	; get dli pos for line
				TAX
				LDA	DISPLAY_LIST,X	; set dli at that screen line
				AND #DLI_INT_CLR
				STA DISPLAY_LIST,X
				DEY
				BPL LOOP
SET_LAST_DLI
			LDA	DL191
			ORA #DLI_INT_SET ; set last dli
			STA	DL191			
			RTS
.ENDL

	.ALIGN $100
DLI_SPR STA REGA
		STX REGX
		STY REGY
		
;        BORDER $7a

		LDA	VCOUNT
		CMP	#VBI_POS
		BCC	SPR_NXT
	
		BORDER $7A

;        BORDER $44

		JSR	CLEAR_OLD_SPRITES	; CLEAR OLD SPRITE POSITIONS (V) OLD SPRITE COUNTER
		JSR	CLEAR_OLD_DLI_SET_LAST_DLI ; clear old interrupts

; COPY NEW V POSITIONS TO OLD V POSITIONS
; COPY NEW SPRITE COUNTER TO OLD SPRITE COUNTER
		
        BORDER $32

		JSR SET_NEW_SPRITES	; SET NEW SPRITE POSITIONS (V) NEW SPRITE COUNTER
		JSR SETUP_FIRST_5_SPRITES_AND_DLIS

		BORDER 0

        LDA REGA
		LDX REGX
		LDY REGY
        RTI

SPR_NXT		; GET NEXT SPRITE FROM LIST AND DRAW IT AND CHECK IF ANY OTHERS NEED TO BE DRAWN
		LDX NEXT_SPRITE
		INC NEXT_SPRITE
		
		LDA	SPR_DLI_TAB,X
		STA SPR_DLI_ADDR+1
		LDA SPR_HOR,X
		LDY SPR_COL,X
		
SPR_DLI_ADDR	JMP	SPR_DLI_0

SPR_DLI_4	STA HPOSM3
			CLC
			ADC #2
			STA HPOSM2
			ADC #2
			STA HPOSM1
			ADC #2
			STA HPOSM0
			STY COLOR3
;			STY COLPF3

;		BORDER 0

; lda spr_ver_dli,x
; cmp spr_ver_dli-1,x
; beq spr_nxt

        LDA REGA
		LDX REGX
		LDY REGY
        RTI

SPR_DLI_3	STA HPOSP3
			STY COLPM3
;			STY PCOLR3

;		BORDER 0

        LDA REGA
		LDX REGX
		LDY REGY
        RTI
		
SPR_DLI_2	STA HPOSP2
			STY COLPM2
;			STY PCOLR2

SPR_DLI_1	STA HPOSP1
			STY COLPM1
;			STY PCOLR1

;		BORDER 0

        LDA REGA
		LDX REGX
		LDY REGY
        RTI

SPR_DLI_0	STA HPOSP0
			STY COLPM0
;			STY PCOLR0

;		BORDER 0

        LDA REGA
		LDX REGX
		LDY REGY
        RTI

.LOCAL	MEMSET
			STY	LSB_ONLY+1 ; store LSB count
			CPX	#0          ; MSB?     
            BEQ	LSB_ONLY   ; no

            LDY	#0          ; yes so reset LSB
MSB_LOOP  
LSB_LOOP    		STA	(SCR),Y   ; clear whole MSB
					DEY 
					BNE	LSB_LOOP

				INC	SCR+1      ; inc MSB
				DEX               ; dec MSB count
				BNE	MSB_LOOP

LSB_ONLY    LDY	#0          ; LSB count 
            BEQ	MS_END     ; not needed

LAST_LSB_LOOP 	STA	(SCR),Y
				DEY 
				BNE	LAST_LSB_LOOP
                
            STA	(SCR),Y     ; clear last Y (0)
MS_END      RTS
.ENDL

SPR_CLR_POS	
.REPT	4
	.BYTE	<SPRITE_CLR_0,<SPRITE_CLR_1,<SPRITE_CLR_2,<SPRITE_CLR_3,<SPRITE_CLR_4
.ENDR
SPR_SET_POS
.REPT	4
	.BYTE	<SPRITE_SET_0,<SPRITE_SET_1,<SPRITE_SET_2,<SPRITE_SET_3,<SPRITE_SET_4
.ENDR
SPR_FIRST_TAB
	.BYTE	<SPRITE_FIRST_0,<SPRITE_FIRST_1,<SPRITE_FIRST_2,<SPRITE_FIRST_3,<SPRITE_FIRST_4 ; 5 or less populate some or all
	.BYTE	<SPRITE_FIRST_4,<SPRITE_FIRST_4,<SPRITE_FIRST_4,<SPRITE_FIRST_4,<SPRITE_FIRST_4 ; more than 5 then fill all
	.BYTE	<SPRITE_FIRST_4,<SPRITE_FIRST_4,<SPRITE_FIRST_4,<SPRITE_FIRST_4,<SPRITE_FIRST_4 ; more than 5 then fill all
	.BYTE	<SPRITE_FIRST_4,<SPRITE_FIRST_4,<SPRITE_FIRST_4,<SPRITE_FIRST_4,<SPRITE_FIRST_4 ; more than 5 then fill all

SPR_DLI_TAB
	.BYTE	<SPR_DLI_0,<SPR_DLI_1,<SPR_DLI_2,<SPR_DLI_3,<SPR_DLI_4
	.BYTE	<SPR_DLI_0,<SPR_DLI_1,<SPR_DLI_2,<SPR_DLI_3,<SPR_DLI_4
	.BYTE	<SPR_DLI_0,<SPR_DLI_1,<SPR_DLI_2,<SPR_DLI_3,<SPR_DLI_4
	.BYTE	<SPR_DLI_0,<SPR_DLI_1,<SPR_DLI_2,<SPR_DLI_3,<SPR_DLI_4

SPR_CNT	.BYTE	14
SPR_VER	.BYTE	40, 50, 60, 70, 80, 90, 100,110,120,130,140,150,160,170,180
SPR_HOR	.BYTE	40, 60, 80, 100,120,140,160,180,170,150,130,110,90, 70, 50
SPR_COL	.BYTE	$22,$44,$66,$88,$28,$46,$36,$26,$82,$64,$48,$86,$62,$48,$62
SPR_VER_DLI	.BYTE	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

	.ALIGN $100
DISPLAY_LIST		
	.BYTE BLANK_LINE,BLANK_LINE,BLANK_LINE	; Discard 24 scan lines
DL000	.BYTE SM
DL001	.BYTE SM
DL002	.BYTE SM
DL003	.BYTE SM
DL004	.BYTE SM
DL005	.BYTE SM
DL006	.BYTE SM
DL007	.BYTE SM
DL008	.BYTE SM
DL009	.BYTE SM

DL010	.BYTE SM
DL011	.BYTE SM
DL012	.BYTE SM
DL013	.BYTE SM
DL014	.BYTE SM
DL015	.BYTE SM
DL016	.BYTE SM
DL017	.BYTE SM
DL018	.BYTE SM
DL019	.BYTE SM

DL020	.BYTE SM
DL021	.BYTE SM
DL022	.BYTE SM
DL023	.BYTE SM
DL024	.BYTE SM
DL025	.BYTE SM
DL026	.BYTE SM
DL027	.BYTE SM
DL028	.BYTE SM
DL029	.BYTE SM

DL030	.BYTE SM
DL031	.BYTE SM
DL032	.BYTE SM
DL033	.BYTE SM
DL034	.BYTE SM
DL035	.BYTE SM
DL036	.BYTE SM
DL037	.BYTE SM
DL038	.BYTE SM
DL039	.BYTE SM

DL040	.BYTE SM
DL041	.BYTE SM
DL042	.BYTE SM
DL043	.BYTE SM
DL044	.BYTE SM
DL045	.BYTE SM
DL046	.BYTE SM
DL047	.BYTE SM
DL048	.BYTE SM
DL049	.BYTE SM

DL050	.BYTE SM
DL051	.BYTE SM
DL052	.BYTE SM
DL053	.BYTE SM
DL054	.BYTE SM
DL055	.BYTE SM
DL056	.BYTE SM
DL057	.BYTE SM
DL058	.BYTE SM
DL059	.BYTE SM

DL060	.BYTE SM
DL061	.BYTE SM
DL062	.BYTE SM
DL063	.BYTE SM
DL064	.BYTE SM
DL065	.BYTE SM
DL066	.BYTE SM
DL067	.BYTE SM
DL068	.BYTE SM
DL069	.BYTE SM

DL070	.BYTE SM
DL071	.BYTE SM
DL072	.BYTE SM
DL073	.BYTE SM
DL074	.BYTE SM
DL075	.BYTE SM
DL076	.BYTE SM
DL077	.BYTE SM
DL078	.BYTE SM
DL079	.BYTE SM

DL080	.BYTE SM
DL081	.BYTE SM
DL082	.BYTE SM
DL083	.BYTE SM
DL084	.BYTE SM
DL085	.BYTE SM
DL086	.BYTE SM
DL087	.BYTE SM
DL088	.BYTE SM
DL089	.BYTE SM

DL090	.BYTE SM
DL091	.BYTE SM
DL092	.BYTE SM
DL093	.BYTE SM
DL094	.BYTE SM
DL095	.BYTE SM
DL096	.BYTE SM
DL097	.BYTE SM
DL098	.BYTE SM
DL099	.BYTE SM

DL100	.BYTE SM
DL101	.BYTE SM
DL102	.BYTE SM
DL103	.BYTE SM
DL104	.BYTE SM
DL105	.BYTE SM
DL106	.BYTE SM
DL107	.BYTE SM
DL108	.BYTE SM
DL109	.BYTE SM

DL110	.BYTE SM
DL111	.BYTE SM
DL112	.BYTE SM
DL113	.BYTE SM
DL114	.BYTE SM
DL115	.BYTE SM
DL116	.BYTE SM
DL117	.BYTE SM
DL118	.BYTE SM
DL119	.BYTE SM

DL120	.BYTE SM
DL121	.BYTE SM
DL122	.BYTE SM
DL123	.BYTE SM
DL124	.BYTE SM
DL125	.BYTE SM
DL126	.BYTE SM
DL127	.BYTE SM
DL128	.BYTE SM
DL129	.BYTE SM

DL130	.BYTE SM
DL131	.BYTE SM
DL132	.BYTE SM
DL133	.BYTE SM
DL134	.BYTE SM
DL135	.BYTE SM
DL136	.BYTE SM
DL137	.BYTE SM
DL138	.BYTE SM
DL139	.BYTE SM

DL140	.BYTE SM
DL141	.BYTE SM
DL142	.BYTE SM
DL143	.BYTE SM
DL144	.BYTE SM
DL145	.BYTE SM
DL146	.BYTE SM
DL147	.BYTE SM
DL148	.BYTE SM
DL149	.BYTE SM

DL150	.BYTE SM
DL151	.BYTE SM
DL152	.BYTE SM
DL153	.BYTE SM
DL154	.BYTE SM
DL155	.BYTE SM
DL156	.BYTE SM
DL157	.BYTE SM
DL158	.BYTE SM
DL159	.BYTE SM

DL160	.BYTE SM
DL161	.BYTE SM
DL162	.BYTE SM
DL163	.BYTE SM
DL164	.BYTE SM
DL165	.BYTE SM
DL166	.BYTE SM
DL167	.BYTE SM
DL168	.BYTE SM
DL169	.BYTE SM

DL170	.BYTE SM
DL171	.BYTE SM
DL172	.BYTE SM
DL173	.BYTE SM
DL174	.BYTE SM
DL175	.BYTE SM
DL176	.BYTE SM
DL177	.BYTE SM
DL178	.BYTE SM
DL179	.BYTE SM

DL180	.BYTE SM
DL181	.BYTE SM
DL182	.BYTE SM
DL183	.BYTE SM
DL184	.BYTE SM
DL185	.BYTE SM
DL186	.BYTE SM
DL187	.BYTE SM
DL188	.BYTE SM
DL189	.BYTE SM

DL190	.BYTE SM
DL191	.BYTE SM+DLI_INT_SET
		.BYTE DISP_LIST,<DISPLAY_LIST,>DISPLAY_LIST

	.ALIGN $100
DLI_TAB	
.REPT 32
 .BYTE <DL191 ; 32 lines off top of screen pointing to last DLI
.ENDR
	.BYTE	<DL000,<DL001,<DL002,<DL003,<DL004,<DL005,<DL006,<DL007,<DL008,<DL009
	.BYTE	<DL010,<DL011,<DL012,<DL013,<DL014,<DL015,<DL016,<DL017,<DL018,<DL019
	.BYTE	<DL020,<DL021,<DL022,<DL023,<DL024,<DL025,<DL026,<DL027,<DL028,<DL029
	.BYTE	<DL030,<DL031,<DL032,<DL033,<DL034,<DL035,<DL036,<DL037,<DL038,<DL039
	.BYTE	<DL040,<DL041,<DL042,<DL043,<DL044,<DL045,<DL046,<DL047,<DL048,<DL049
	.BYTE	<DL050,<DL051,<DL052,<DL053,<DL054,<DL055,<DL056,<DL057,<DL058,<DL059
	.BYTE	<DL060,<DL061,<DL062,<DL063,<DL064,<DL065,<DL066,<DL067,<DL068,<DL069
	.BYTE	<DL070,<DL071,<DL072,<DL073,<DL074,<DL075,<DL076,<DL077,<DL078,<DL079
	.BYTE	<DL080,<DL081,<DL082,<DL083,<DL084,<DL085,<DL086,<DL087,<DL088,<DL089
	.BYTE	<DL090,<DL091,<DL092,<DL093,<DL094,<DL095,<DL096,<DL097,<DL098,<DL099
	.BYTE	<DL100,<DL101,<DL102,<DL103,<DL104,<DL105,<DL106,<DL107,<DL108,<DL109
	.BYTE	<DL110,<DL111,<DL112,<DL113,<DL114,<DL115,<DL116,<DL117,<DL118,<DL119
	.BYTE	<DL120,<DL121,<DL122,<DL123,<DL124,<DL125,<DL126,<DL127,<DL128,<DL129
	.BYTE	<DL130,<DL131,<DL132,<DL133,<DL134,<DL135,<DL136,<DL137,<DL138,<DL139
	.BYTE	<DL140,<DL141,<DL142,<DL143,<DL144,<DL145,<DL146,<DL147,<DL148,<DL149
	.BYTE	<DL150,<DL151,<DL152,<DL153,<DL154,<DL155,<DL156,<DL157,<DL158,<DL159
	.BYTE	<DL160,<DL161,<DL162,<DL163,<DL164,<DL165,<DL166,<DL167,<DL168,<DL169
	.BYTE	<DL170,<DL171,<DL172,<DL173,<DL174,<DL175,<DL176,<DL177,<DL178,<DL179
	.BYTE	<DL180,<DL181,<DL182,<DL183,<DL184,<DL185,<DL186,<DL187,<DL188,<DL189
	.BYTE	<DL190,<DL191

	.ALIGN 2047 ; 1023
PM_SHAPE_TAB
.REPT	256*3
	.BYTE 0 ; 768 BYTES SPARE
.ENDR
SPRITE4_TAB
.REPT	256
	.BYTE %10100101
.ENDR
SPRITE0_TAB
.REPT	256
	.BYTE %10000001
.ENDR
SPRITE1_TAB
.REPT	256
	.BYTE %11100111
.ENDR
SPRITE2_TAB
.REPT	256
	.BYTE %11110101
.ENDR
SPRITE3_TAB
.REPT	256
	.BYTE %10101111
.ENDR

.ALIGN $1000
SCN ; screen
.REPT 1024
	.BYTE 0,0,0,0,0,0 ;$00,$FF,$AA,$55,$ff,$00
.ENDR

;gprior (623/$026F) is set to 52/$34

 

;04/$04 = priority PF0-PF1-PF2-PF3 P0-P1-P2-P3 BAK

;16/$10 = Four Missiles add up to be 5th player

;32/$20 = Overlapping Players have 3rd color


; ldx next-sprite
; inc next-sprite
; get next sprite number,x
; store address
; jump next sprite address
